version: "2.12"

services:

  rabbitmq:
    # Use built image by official redis
    image: "rabbitmq:3.9.24-alpine"
    # redis default port open to 5672 for local network ip address access
    ports:
      - "5672:5672"
    healthcheck:
      test: rabbitmq-diagnostics -q ping
      interval: 15s
      timeout: 10s
      retries: 5

  redis:
    # Use built image by official redis
    image: "redis:7.0.5-alpine3.16"
    # redis default port open to 6379 for local network ip address access
    ports:
      - "6379:6379"

  vue:
    # Build by yourself after changing `./vue/app/Dockerfile`, or use built image on my dockerhub
    # image: "mrxir/rec2vqa:vue"
    build: 
      context: "./vue/app/"
      args:
        - NODE_ENV=development
    # Use 80 convenient port for vue app access through local network ip
    ports:
      - "80:8080"
      - "9229:9229"
      - "9230:9230"
    volumes:
      - ./vue/app:/opt/node_app/app
      # bind-mounting these two files in will let you add packages during development without rebuilding
      # for example, to add bower to your app while developing, just install it inside the container
      # and then nodemon will restart. Your changes will last until you "docker compose down" and will
      # be saved on host for next build.
      # remember to isntall from the parent directory to the code bind-mount:
      # docker compose exec -w /opt/node_app node npm install --save bower
      - ./vue/app/package.json:/opt/node_app/package.json
      - ./vue/app/package-lock.json:/opt/node_app/package-lock.json
      # this is a workaround to prevent host node_modules from accidently getting mounted in container
      # in case you want to use node/npm both outside container for test/lint etc. and also inside container
      # this will overwrite the default node_modules dir in container so it won't conflict with our
      # /opt/node_app/node_modules location. Thanks to PR from @brnluiz
      - notused:/opt/node_app/app/node_modules

  django:
    # Build by yourself after changing `./django/Dockerfile`, or use built image on my dockerhub
    build: "./django"
    # image: "mrxir/rec2vqa:django"
    # Use 8080 default django port for local network ip address access
    ports:
      - "8080:8080"
    volumes:
      - type: bind
        source: ./django
        target: /work
      - django_db:/work/db
      - django_migrations:/work/api/migrations
      - django_media:/work/media
      - django_static:/work/static
    depends_on:
      - "redis"

  vlbert-recworker:
    # Build by yourself after changing `./vlbert/Dockerfile`, or use built image on my dockerhub
    # build: "./vlbert/"
    image: "mrxir/rec2vqa:vlbert"
    volumes:
      - type: bind
        source: ./
        target: /work
    # nvidia-docker gpu support for all devices
    deploy:
      resources:
        reservations:
          devices:
            - capabilities: [gpu]
    # Run vlbert runtime cuda build installation, and then run rec worker program
    command: bash -c "cd ./django && python recworker.py"
    depends_on:
      rabbitmq:
        condition: service_healthy

  vlbert-vqaworker:
    # Build by yourself after changing `./vlbert/Dockerfile`, or use built image on my dockerhub
    # build: "./vlbert/"
    image: "mrxir/rec2vqa:vlbert"
    volumes:
      - type: bind
        source: ./
        target: /work
    # nvidia-docker gpu support for all devices
    deploy:
      resources:
        reservations:
          devices:
            - capabilities: [gpu]
    # Run vlbert runtime cuda build installation, and then run vqa worker program
    command: bash -c "cd ./django && python vqaworker.py"
    depends_on:
      rabbitmq:
        condition: service_healthy

volumes:
  notused:
  django_db:
  django_migrations:
  django_media:
  django_static:
